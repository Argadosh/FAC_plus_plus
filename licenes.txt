Лекции по "Фундаментальные алгоритмам на с++"

11.09.24

Лепчинский Михаил Германович

email - migele.csu@gmail.com

Литература:
	Кормен, Лейзерсон, Ривест, Штайн 
		Алгоритмы. Построение и анализ Издание 3-е
	Дасгупта, Пападимитриу, Визирани
		Алгоритмы
	Дональд Кнут
		Искусство программирования. Том 1-3
	Абрамов
		Лекции о сложности алгоритмов
	Справочник по с++
		www.cppreference.com

Бально-рейтинговая система
1) Домашние задания:
	Начисляется 1 сырой балл за каждое сделанное задание.
		Максимум 60 итоговых баллов за домашние задания
2) Семестровое задание
	Два задания по темам практик и лекций
		Максимум 15 + 15 итоговых балла
3) Экзамен
	Два вопроса в билете
		Максимум 10 + 10 итоговых балла
	
Оценка:
	3 - 60
	4 - 75
	5 - 90

c++ 11 и его особенности

	1) ссылки на временные обьекты и семантика перемещения rvalue-ссылки T&&, std::move(), std::forward()
	2) Обобщённые константные выражения constexp
	3) списки инициализации 
		SquenceClass someVar = {1,4,5,6}
	4) Универсальная инициализация
		SomeClass someVar {"some_value", 4}
	5) Вывод типов. Ключевое слово auto
	6) For - цикл по коллекции
		for(int &x : my_array)
	7) Лямбда - функции и выражения
		[](intx, int y) {return x+y;}
	8) Константа нулевого указателя nullptr
	9) Перечисления со строгой типизацией 
		enum class Enumeration {val1,val2,val3};
	10) Создание алиасов для классов вместо typedef
		using intvec = std::vector <int> 
	11) Шаблоны с переменным числом аргументов
		template <typename ... Values> class tuple
	12) Расширяемые классы генерации случайных чисел

Строго следуйте code style "гайдам", принятым в вашей корпоративной среде

https:/tproger.ru/translations/stanford-cpp-style-guide

25.09.24

Тема: <Структуры данных>

	Stack и его применение в алгоритмах

Опр.
	Steck-ом называется обстрактный тип данных, обладающий следующим набором операций:
		1) push(x) - положить x на вершину steck
		2) pop() - извлечь вершину
		3) top() - прочитать вершину
		4) size() - получить размер steck
		
Возможные реализации stack:
	1) Реализация с помощью массивов.
		Для хранения эл-ов stack резервируется массив зараннее определённого размера и создаётся счётчик count, который показывает на первую свободную ячейку
	2) Реализация с помощью связного списка.
		Вершина -> [data|next] -> [data|next] -> ... -> [ | ] ->
		1) push
			{x, next} -> top -> [|] -> [|] -> ...
			после перекинуть top перед первой ячейкой
		2) pop
		top -> [|] -> [|] ->
		tmp = top;
		top = top.next;
		delete tmp;
	3) Реализация с помощью "расширяемого" массива
		Для хранения данных выделяется массив.
		При этом, если операция push должна привести к переполнению этого массива,
			то выделяется массив в два раза большего размера, в который переносятся данные из старого.
	4) Комбинированная реализация
		Для хранения используем список массивов
			[|||] -> [|||||] -> [||||||||] ->
		Политика увеличения размеров чанков:
			1) Постоянный размер ( к примеру 100 )
			2) Линейный рост: (100, 200, 300, ....)
			3) Квадратичный рост: (100, 400, 900, 1600, ....)
			4) Экспонециальный рост: (2^0 * 100, 2^1 * 100, 2^3 * 100, ... )
		Политика удаления чанков:
			1) Когда опустошается половина последнего чанка, то опустошаем пустой чанк
			2) Когда опустошаются два последних чанка, опустошаем последний пустой чанк
Интерфейс класса stack:
	
	1) С помощью массива:
		template <typename T>
		class stack_m{
		private:
			T* data;
			size_t capacity, count;
		public:
			stack_m(size_t _capacity = 50000);
			~stack_m();
			void push(const T &new_top);
			void push(T&& new_top);
			void pop();
			T& top();
			const T& top() const;
			size_t size() const;
			stack_m(const stack_m<T> &obj);
			stack_m(stack_m<T> &&obj);
			stack_m<T>& operator= (const stack_m<T> &obj);
			stack_m<T>& operator= (stack_m<T> &&obj);
		};
		
		template <typename T>
		stack_m<T>::stack_m(size_t _capacity){
			count = 0;
			capacity = _capacity;
			data = new T[capacity];
		}
		template <typename T>
		stack_m<T>::~stack_m(){
			delete []data;
		}
		template <typename T>
		void stack_m<T>::push(const T &new_top){
			if (count == capacity){
				throw std::overflow(); //Возможно не прям так.
			}
			data[count++] = new_top;
		}
		template <typename T>
		void stack_m<T>::push(T&& new_top){
			if (count == capacity){
				throw std::overflow(); //Возможно не прям так.
			}
			data[count++] = new_top;
		}