Лекции по "Фундаментальные алгоритмам на с++"

11.09.24

Лепчинский Михаил Германович

email - migele.csu@gmail.com

Литература:
	Кормен, Лейзерсон, Ривест, Штайн 
		Алгоритмы. Построение и анализ Издание 3-е
	Дасгупта, Пападимитриу, Визирани
		Алгоритмы
	Дональд Кнут
		Искусство программирования. Том 1-3
	Абрамов
		Лекции о сложности алгоритмов
	Справочник по с++
		www.cppreference.com

Бально-рейтинговая система
1) Домашние задания:
	Начисляется 1 сырой балл за каждое сделанное задание.
		Максимум 60 итоговых баллов за домашние задания
2) Семестровое задание
	Два задания по темам практик и лекций
		Максимум 15 + 15 итоговых балла
3) Экзамен
	Два вопроса в билете
		Максимум 10 + 10 итоговых балла
	
Оценка:
	3 - 60
	4 - 75
	5 - 90

c++ 11 и его особенности

	1) ссылки на временные обьекты и семантика перемещения rvalue-ссылки T&&, std::move(), std::forward()
	2) Обобщённые константные выражения constexp
	3) списки инициализации 
		SquenceClass someVar = {1,4,5,6}
	4) Универсальная инициализация
		SomeClass someVar {"some_value", 4}
	5) Вывод типов. Ключевое слово auto
	6) For - цикл по коллекции
		for(int &x : my_array)
	7) Лямбда - функции и выражения
		[](intx, int y) {return x+y;}
	8) Константа нулевого указателя nullptr
	9) Перечисления со строгой типизацией 
		enum class Enumeration {val1,val2,val3};
	10) Создание алиасов для классов вместо typedef
		using intvec = std::vector <int> 
	11) Шаблоны с переменным числом аргументов
		template <typename ... Values> class tuple
	12) Расширяемые классы генерации случайных чисел

Строго следуйте code style "гайдам", принятым в вашей корпоративной среде

https:/tproger.ru/translations/stanford-cpp-style-guide

25.09.24

Тема: <Структуры данных>

	Stack и его применение в алгоритмах

Опр.
	Steck-ом называется обстрактный тип данных, обладающий следующим набором операций:
		1) push(x) - положить x на вершину steck
		2) pop() - извлечь вершину
		3) top() - прочитать вершину
		4) size() - получить размер steck
		
Возможные реализации stack:
	1) Реализация с помощью массивов.
		Для хранения эл-ов stack резервируется массив зараннее определённого размера и создаётся счётчик count, который показывает на первую свободную ячейку
	2) Реализация с помощью связного списка.
		Вершина -> [data|next] -> [data|next] -> ... -> [ | ] ->
		1) push
			{x, next} -> top -> [|] -> [|] -> ...
			после перекинуть top перед первой ячейкой
		2) pop
		top -> [|] -> [|] ->
		tmp = top;
		top = top.next;
		delete tmp;
	3) Реализация с помощью "расширяемого" массива
		Для хранения данных выделяется массив.
		При этом, если операция push должна привести к переполнению этого массива,
			то выделяется массив в два раза большего размера, в который переносятся данные из старого.
	4) Комбинированная реализация
		Для хранения используем список массивов
			[|||] -> [|||||] -> [||||||||] ->
		Политика увеличения размеров чанков:
			1) Постоянный размер ( к примеру 100 )
			2) Линейный рост: (100, 200, 300, ....)
			3) Квадратичный рост: (100, 400, 900, 1600, ....)
			4) Экспонециальный рост: (2^0 * 100, 2^1 * 100, 2^3 * 100, ... )
		Политика удаления чанков:
			1) Когда опустошается половина последнего чанка, то опустошаем пустой чанк
			2) Когда опустошаются два последних чанка, опустошаем последний пустой чанк
Интерфейс класса stack:
	
	1) С помощью массива:
		template <typename T>
		class stack_m{
		private:
			T* data;
			size_t capacity, count;
		public:
			stack_m(size_t _capacity = 50000);
			~stack_m();
			void push(const T &new_top);
			void push(T&& new_top);
			void pop();
			T& top();
			const T& top() const;
			size_t size() const;
			stack_m(const stack_m<T> &obj);
			stack_m(stack_m<T> &&obj);
			stack_m<T>& operator= (const stack_m<T> &obj);
			stack_m<T>& operator= (stack_m<T> &&obj);
		};
		
		template <typename T>
		stack_m<T>::stack_m(size_t _capacity){
			count = 0;
			capacity = _capacity;
			data = new T[capacity];
		}
		template <typename T>
		stack_m<T>::~stack_m(){
			delete []data;
		}
		template <typename T>
		void stack_m<T>::push(const T &new_top){
			if (count == capacity){
				throw std::overflow(); //Возможно не прям так.
			}
			data[count++] = new_top;
		}
		template <typename T>
		void stack_m<T>::push(T&& new_top){
			if (count == capacity){
				throw std::overflow(); //Возможно не прям так.
			}
			data[count++] = new_top;
		}
		
09.10.24

Алгоритмы со стеками

1) Задача о правильных скобочных выражениях
	Дана последовательность открывающихся и закрывающихся скобочек нескольких типов. 
	Требуется определить является ли эта скобочная последовательность правильной.
	
	Определение: Правильными скобочными выражениями называются последовательности, которые могут быть построены путём применения следующих трёх правил:
		1) Пустая последователньость правильная
		2) Если s - правильная последователньость, то (s) - тоже правильная
		3) Если s1 и s2 - правильные, то конкатинация s1,s2 - тоже
		
	Алгоритм проверки правильности:
		1) Создаём стек скобок S 
		2) Просматриваем последователньость слева направо:
			Если очередная скобка:
				Если открывающаяя - заносим в S 
				Если закрывающаяя:
					Если она парная к S.top(), то делаем S.pop()
					Иначе последователньость неправильная
			Если S - пустой, то последовательность правильная
			иначе неправильная 

2) Задача о мажорирующем элементе
	Дана последователньость элементов. 
	Требуется выяснить, есть ли среди них мажор 
	
	Определение: Мажорирующим эл-ом последовательности называется такое значение, которое встречается в последовательности больше половины раз 
	
	Алгоритм большинства голосов:
		1) Создаём стек элементов S.
		2) Просматриваем последователньость слева направо 
			Если стек пуст, то закидываем в него текущий элемент 
			Если стек не пуст, то сравниваем текущий элемент и S.top()
				Если равны, то S.push()
				Если не равны, то S.pop()
		3) Если в конце в стеке ничего нет, то мажора нет
			Иначе считаем сколько раз S.top() встречается в последовательности
				Если встречается больше половины раз, то это мажор
				Иначе нет мажора.
				
3) Алгоритм нахождения эйлерова пути в графе

	Определение: Пусть G - граф, ориентированный или неориентированный. 
	Эйлеровым путём в G называется путь, который проходит по каждому ребру G ровно 1 раз
	
	Алгоритм:
		1) Создаём стек вершин S
			Если в графе G две нечётные вершины, то заносим в S любую из них. Иначе вообще любую заносим.
			
			Определение: Вершина называется чётной, если из неё выходит чётнео кол-во рёбер.
		2) Пока стек S не опустел:
			Читаем вершину u = S.top();
			Если в графе G есть непройденное ребро u-v, то S.push(v), а ребро u-v помечаем пройдённым. Иначе дописываем u в конец пути и S.pop()
			
4) Задача о построение выпуклой оболочки множества точек

	Дано конечное множество точпек на плоскости
	Требуется указать наименьший выпуклый многоугольник, содержащий все эти точки, перечислив в порядке обхода все его вершины
	
	
	Алгоритм:
		Шаг 1: Находим самую нижнюю точку множества, присваиваем ей номер 0.
		Шаг 2: Нумеруем оставшиеся точки, от 1 до n - 1 в порядке возрастания полярного угла из точки с номером 0.
		Шаг 3: Обход Грэхема.
			Создаём стек точек S.
			Заносим в S 0 и 1.
			Просматриваем оставшиеся точки от 2 и по возрастанию.
				1) Пусть на вершине стека лежат т. а и б.
				2) Пусть текущаяя точка имеет номер с.
				3) Если поворот от вектора аб к ветктору бс происходит против часовой стрелки, то мы помещаем точку с в стек S.
				4) Иначе мы делаем S.pop() и идём в пункт (1).
			В конце, всё что отслаось в стеке - это и есть вершины выпуклой оболочки в порядке обхода.